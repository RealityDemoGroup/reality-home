<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Reality home</title>
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.145.0/build/three.module.js",
				"stats": "https://unpkg.com/three@0.145.0/examples/jsm/libs/stats.module.js",
				"gui": "https://unpkg.com/three@0.145.0/examples/jsm/libs/lil-gui.module.min.js",
				"gltfLoader": "https://unpkg.com/three@0.145.0/examples/jsm/loaders/GLTFLoader.js",
				"dracoLoader": "https://unpkg.com/three@0.145.0/examples/jsm/loaders/DRACOLoader.js",
				"fontLoader": "https://unpkg.com/three@0.145.0/examples/jsm/loaders/FontLoader.js",
				"textGeometry": "https://unpkg.com/three@0.145.0/examples/jsm/geometries/TextGeometry.js",
				"orbitcontrols": "https://unpkg.com/three@0.145.0/examples/jsm/controls/OrbitControls.js",
				"effectComposer": "https://unpkg.com/three@0.145.0/examples/jsm/postprocessing/EffectComposer.js",
				"renderPass": "https://unpkg.com/three@0.145.0/examples/jsm/postprocessing/RenderPass.js",
				"glitchPass": "https://unpkg.com/three@0.145.0/examples/jsm/postprocessing/GlitchPass.js",
				"scroller": "./scroller.js"
			}
		}
	</script>
	<script type="module">
		import * as THREE from 'three';
		import Stats from 'stats';
		import GUI from 'gui';

		import { OrbitControls } from 'orbitcontrols';
		import { GLTFLoader } from 'gltfLoader';
		import { DRACOLoader } from 'dracoLoader';
		import { FontLoader } from 'fontLoader';
		import { TextGeometry } from 'textGeometry';

		import  { Scroller } from 'scroller';
		
		import { EffectComposer } from 'effectComposer';
		import { RenderPass } from 'renderPass';
		import { GlitchPass } from 'glitchPass';

		let camera, scene, controls, renderer, composer, loader;
		const cameraPosition = new THREE.Vector3(0, 3, 7);
		let cubeCamera, cubeRenderTarget;
		let gui, stats;
		let logo, bg;
		let glitchPass;
		let loaderFont, scroll;
		let scrollText = "Welcome to Reality home! This small intro is done for fun by Quille. --->";

		let guiValues = {
			paused: false,
			animateCamera: true,
			glitchFx: false,
			scrollPos: 0,
			scrollMin: 0,
			scrollMax: Math.PI * 4,
			scrollStep: Math.PI / 320,
			scrollUp: function() {
				guiValues.scrollPos += guiValues.scrollStep;
			},
			scrollDown: function() {
				guiValues.scrollPos -= guiValues.scrollStep;
			}
		}

		function initLoader(){
			// mesh loader
			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath('https://unpkg.com/three@0.145.0/examples/js/libs/draco/');
			// (Optional) Override detection of WASM support.
			//dracoLoader.setDecoderConfig({type: 'js'});
			// init object loader with decompressor
			loader = new GLTFLoader();
			loader.setDRACOLoader(dracoLoader);

			// font loader
			loaderFont = new FontLoader();
		}

		function disposeArray() {
			this.array = null;
		}

		function createPyramid(v1, v2, v3, mat) {
			// trinagle from base vertex
			const t = new THREE.Triangle(v1, v2, v3);
			// normal
			const n = new THREE.Vector3();
			t.getNormal(n);
			// midpoint will be v4
			const v4 = new THREE.Vector3();
			t.getMidpoint(v4);
			// center point, center point direction
			const c = v4.clone();
			const cd = n.clone();

			// http://www.mathematische-basteleien.de/tetrahedron.htm
			// height calc
			const edgeLen = v1.distanceTo(v2);
			const height = Math.sqrt(3) / 4 * edgeLen; 

			// position 4th vertex
			n.multiplyScalar(height);	// size normal to height
			v4.add(n);					// position normal to space

			// position pyramid center point
			cd.multiplyScalar(height / 3);
			c.add(cd);

			// position pyramid to center
			v1.sub(c);
			v2.sub(c);
			v3.sub(c);
			v4.sub(c);

			const pos = new Float32Array([
				v1.x, v1.y, v1.z,
				v3.x, v3.y, v3.z,
				v2.x, v2.y, v2.z,

				v1.x, v1.y, v1.z,
				v2.x, v2.y, v2.z,
				v4.x, v4.y, v4.z,
				
				v3.x, v3.y, v3.z,
				v1.x, v1.y, v1.z,
				v4.x, v4.y, v4.z,

				v3.x, v3.y, v3.z,
				v4.x, v4.y, v4.z,
				v2.x, v2.y, v2.z,
			]);

			const g = new THREE.BufferGeometry();
			g.setAttribute( 'position', new THREE.Float32BufferAttribute( pos, 3 ) );
			g.setAttribute( 'normal', new THREE.Float32BufferAttribute( pos.slice(), 3 ).onUpload( disposeArray ) );
			const m = new THREE.Mesh(g, mat);
			m.translateX(c.x);
			m.translateY(c.y);
			m.translateZ(c.z);
			return m;
		}

		function createBG(bg, mat) {
			const geo = new THREE.IcosahedronGeometry(8, 15);
			//bg.add(new THREE.Mesh(geo, mat));

			const p = geo.attributes.position;
			let noTri = p.count / 3;	// number of triangles
			//console.log("BG Triangles", noTri);			
			//noTri = 50;

			// do some triangles
			let o = 0; // offset in arrays
			for (let i = 0; i < noTri; i++) {
				const v1 = new THREE.Vector3().fromArray(p.array, o);
				o += 3;
				const v2 = new THREE.Vector3().fromArray(p.array,o);
				o += 3;
				const v3 = new THREE.Vector3().fromArray(p.array,o);
				o += 3;
				bg.add(createPyramid(v1, v2, v3, mat));
			}
		}

		function init() {
			initLoader();

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 20 );
			camera.position.x = cameraPosition.x;
			camera.position.y = cameraPosition.y;
			camera.position.z = cameraPosition.z;

			const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
			pointLight.position.set( 0, 2, 2 );
			camera.add( pointLight );
			scene.add( camera );

			//const mat = new THREE.MeshStandardMaterial({color: 0x00ff00, flatShading:true, side:THREE.FrontSide});
			const mat = new THREE.MeshStandardMaterial({color: 0xccccff, flatShading:true, side:THREE.FrontSide});

			// background
			bg = new THREE.Group();
			createBG(bg, mat);
			scene.add(bg);

			// reflection on cube map for logo
			cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );
			cubeRenderTarget.texture.type = THREE.HalfFloatType;
			cubeCamera = new THREE.CubeCamera( 0.01, 20, cubeRenderTarget );
			const matLogo = new THREE.MeshStandardMaterial({
				envMap: cubeRenderTarget.texture,
				roughness: 0.05,
				metalness: 1,
				color: 0x4444aa,
				//flatShading:true,
			});

			// load me a logo
			loader.load('mesh/reality_logo.glb', function (glTF) {
				logo = glTF.scene.children[0];
				//logo.material = new THREE.MeshStandardMaterial({color:0xff000099,flatShading:true});;
				logo.material = matLogo;
				scene.add(logo);
			});

			// load me a font and kickstart scrolling
			loaderFont.load('font/Orbitron_Regular.json', function(font) {
				const mat = new THREE.MeshStandardMaterial({color: 0x0000ff, flatShading:true, side:THREE.FrontSide});
				const sc = new Scroller(scrollText, font, mat);
				const sg = sc.create();
				scene.add(sg);
				scroll = sc;	// this will enable rendering
			});

			renderer = new THREE.WebGLRenderer({
				antialias: true,
				powerPreference: "high-performance",
			});
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.outputEncoding = THREE.sRGBEncoding;
			//renderer.toneMapping = THREE.ACESFilmicToneMapping;
			if (!guiValues.paused) {
				renderer.setAnimationLoop( animate );
			}
			document.body.appendChild( renderer.domElement );

			// postprocessing
			composer = new EffectComposer( renderer );
			composer.addPass( new RenderPass( scene, camera ) );
			// post process effect 
			glitchPass = new GlitchPass();
			composer.addPass( glitchPass );

			controls = new OrbitControls( camera, renderer.domElement );

			stats = new Stats();
			document.body.appendChild( stats.dom );
			window.addEventListener( 'resize', onWindowResize );
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate(time) {
			render(time);
			stats.update();
		}

		function render(time) {
			if (bg) {
				for (let i = 0; i < bg.children.length; i++) {
					bg.children[i].rotation.x = time / 1000;
					bg.children[i].rotation.y = time / 400;
					bg.children[i].rotation.z = time / 2000;
				}
			}

			if (logo) {
				logo.rotation.y = time / 8000;
				// reflection on cube map
				logo.visible = false;
				cubeCamera.update( renderer, scene );
				logo.visible = true;
			}

			if (scroll) {
				scroll.render(time);
				//scroll.render(guiValues.scrollPos * scroll.speed);
			}

			// animate camera
			if (guiValues.animateCamera) {
				const cr = new THREE.Euler( time / 8000, time / 12000, time / 4000, 'XYZ' );
				const cp = cameraPosition.clone();
				cp.applyEuler(cr);
				camera.position.x = cp.x;
				camera.position.y = cp.y;
				camera.position.z = cp.z;
				camera.lookAt(0,0,0);
			}

			if (guiValues.glitchFx) {
				composer.render();
			} else {
				renderer.render( scene, camera );
			}
		}

		// gui stuff
		gui = new GUI();
		gui.add(guiValues, 'paused').onChange(function(paused) {
			if (!paused) {
				renderer.setAnimationLoop( animate );
			} else {
				renderer.setAnimationLoop( null );
			}
		});
		gui.add(guiValues, 'animateCamera').onChange(function(animateCamera) {
			if (!animateCamera) {
				camera.position.x = cameraPosition.x;
				camera.position.y = cameraPosition.y;
				camera.position.z = cameraPosition.z;
				camera.lookAt(0,0,0);
			}
		});;
		gui.add(guiValues, 'glitchFx');
		//gui.add(guiValues, 'scrollPos', guiValues.scrollMin, guiValues.scrollMax, guiValues.scrollStep).listen();
		//gui.add(guiValues, 'scrollUp');
		//gui.add(guiValues, 'scrollDown');

		// start all
		init();	
	</script>
</body>
</html>