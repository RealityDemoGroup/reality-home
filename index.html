<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Reality home</title>
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.140.0/build/three.module.js",
				"stats": "https://unpkg.com/three@0.140.0/examples/jsm/libs/stats.module.js",
				"gui": "https://unpkg.com/three@0.140.0/examples/jsm/libs/lil-gui.module.min.js",
				"gltfLoader": "https://unpkg.com/three@0.140.0/examples/jsm/loaders/GLTFLoader.js",
				"dracoLoader": "https://unpkg.com/three@0.140.0/examples/jsm/loaders/DRACOLoader.js",
				"orbitcontrols": "https://unpkg.com/three@0.140.0/examples/jsm/controls/OrbitControls.js",
				"effectComposer": "https://unpkg.com/three@0.140.0/examples/jsm/postprocessing/EffectComposer.js",
				"renderPass": "https://unpkg.com/three@0.140.0/examples/jsm/postprocessing/RenderPass.js",
				"glitchPass": "https://unpkg.com/three@0.140.0/examples/jsm/postprocessing/GlitchPass.js"
			}
		}
	</script>
	<script type="module">
		import * as THREE from 'three';
		import Stats from 'stats';
		import GUI from 'gui';

		import { OrbitControls } from 'orbitcontrols';
		import { GLTFLoader } from 'gltfLoader';
		import { DRACOLoader } from 'dracoLoader';
		
		import { EffectComposer } from 'effectComposer';
		import { RenderPass } from 'renderPass';
		import { GlitchPass } from 'glitchPass';

		let camera, scene, controls, renderer, composer, loader;
		let cubeCamera, cubeRenderTarget;
		let gui, stats;
		let logo, bg;
		let glitchPass;

		let guiValues = {
			paused: false,
			glitchFx: false,
		}

		function initLoader(){
			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath('https://unpkg.com/three@0.140.0/examples/js/libs/draco/');
			// (Optional) Override detection of WASM support.
			//dracoLoader.setDecoderConfig({type: 'js'});
			// init object loader with decompressor
			loader = new GLTFLoader();
			loader.setDRACOLoader(dracoLoader);
		}

		function disposeArray() {
			this.array = null;
		}

		function createPyramid(v1, v2, v3, mat) {
			// trinagle from base vertex
			const t = new THREE.Triangle(v1, v2, v3);
			// normal
			const n = new THREE.Vector3();
			t.getNormal(n);
			// midpoint will be v4
			const v4 = new THREE.Vector3();
			t.getMidpoint(v4);
			// center point, center point direction
			const c = v4.clone();
			const cd = n.clone();

			// http://www.mathematische-basteleien.de/tetrahedron.htm
			// height calc
			const edgeLen = v1.distanceTo(v2);
			const height = Math.sqrt(3) / 4 * edgeLen; 

			// position 4th vertex
			n.multiplyScalar(height);	// size normal to height
			v4.add(n);					// position normal to space

			// position pyramid center point
			cd.multiplyScalar(height / 3);
			c.add(cd);

			// position pyramid to center
			v1.sub(c);
			v2.sub(c);
			v3.sub(c);
			v4.sub(c);

			const pos = new Float32Array([
				v1.x, v1.y, v1.z,
				v3.x, v3.y, v3.z,
				v2.x, v2.y, v2.z,

				v1.x, v1.y, v1.z,
				v2.x, v2.y, v2.z,
				v4.x, v4.y, v4.z,
				
				v3.x, v3.y, v3.z,
				v1.x, v1.y, v1.z,
				v4.x, v4.y, v4.z,

				v3.x, v3.y, v3.z,
				v4.x, v4.y, v4.z,
				v2.x, v2.y, v2.z,
			]);

			const g = new THREE.BufferGeometry();
			g.setAttribute( 'position', new THREE.Float32BufferAttribute( pos, 3 ) );
			g.setAttribute( 'normal', new THREE.Float32BufferAttribute( pos.slice(), 3 ).onUpload( disposeArray ) );
			const m = new THREE.Mesh(g, mat);
			m.translateX(c.x);
			m.translateY(c.y);
			m.translateZ(c.z);
			return m;
		}

		function createBG(bg, mat) {
			const geo = new THREE.IcosahedronGeometry(5, 15);
			//bg.add(new THREE.Mesh(geo, mat));

			const p = geo.attributes.position;
			let noTri = p.count / 3;	// number of triangles
			//console.log("BG Triangles", noTri);			
			//noTri = 50;

			// do some triangles
			let o = 0; // offset in arrays
			for (let i = 0; i < noTri; i++) {
				const v1 = new THREE.Vector3(p.array[o], p.array[o+1], p.array[o+2]);
				o += 3;
				const v2 = new THREE.Vector3(p.array[o], p.array[o+1], p.array[o+2]);
				o += 3;
				const v3 = new THREE.Vector3(p.array[o], p.array[o+1], p.array[o+2]);
				o += 3;
				bg.add(createPyramid(v1, v2, v3, mat));
			}
		}

		function init() {
			initLoader();

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 20 );
			camera.position.z = 2.5;

			const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
			pointLight.position.set( 0, 2, 2 );
			camera.add( pointLight );
			scene.add( camera );

			const mat = new THREE.MeshStandardMaterial({color: 0x00ff00, flatShading:true, side:THREE.FrontSide});

			// reflection on cube map
			//cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 512 );
			//cubeRenderTarget.texture.type = THREE.HalfFloatType;
			//cubeCamera = new THREE.CubeCamera( 0.01, 20, cubeRenderTarget );
			//cubeCamera.position.set( 0, 0, 2.5 );
			//const mat = new THREE.MeshStandardMaterial({
			//	envMap: cubeRenderTarget.texture,
			//	roughness: 0.05,
			//	metalness: 1,
			//	side: THREE.BackSide
			//});

			// background
			bg = new THREE.Group();
			createBG(bg, mat);
			scene.add(bg);

			// load me a logo
			loader.load('mesh/reality_logo.glb', function (glTF) {
				logo = glTF.scene.children[0];
				const mat = new THREE.MeshStandardMaterial({color:0xff000099,flatShading:true});
				//const mat = new THREE.MeshStandardMaterial({color:0xffcccccc,flatShading:true});
				logo.material = mat;
				scene.add(logo);
			});			

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.outputEncoding = THREE.sRGBEncoding;
			//renderer.toneMapping = THREE.ACESFilmicToneMapping;
			if (!guiValues.paused) {
				renderer.setAnimationLoop( animate );
			}
			document.body.appendChild( renderer.domElement );

			// postprocessing
			composer = new EffectComposer( renderer );
			composer.addPass( new RenderPass( scene, camera ) );
			// post process effect 
			glitchPass = new GlitchPass();
			composer.addPass( glitchPass );

			controls = new OrbitControls( camera, renderer.domElement );

			stats = new Stats();
			document.body.appendChild( stats.dom );
			window.addEventListener( 'resize', onWindowResize );
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate(time) {
			render(time);
			stats.update();
		}

		function render(time) {
			if (logo) {
				logo.rotation.y = time / 2000;
			}
			if (bg) {
				for (let i = 0; i < bg.children.length; i++) {
					bg.children[i].rotation.x = time / 1000;
					bg.children[i].rotation.y = time / 400;
					bg.children[i].rotation.z = time / 2000;
				}
			}
			// reflection on cube map
			// cubeCamera.update( renderer, scene );
			if (guiValues.glitchFx) {
				composer.render();
			} else {
				renderer.render( scene, camera );
			}
		}

		// gui stuff
		gui = new GUI();
		gui.add(guiValues, 'paused').onChange(function(paused) {
			if (!paused) {
				renderer.setAnimationLoop( animate );
			} else {
				renderer.setAnimationLoop( null );
			}
		});
		gui.add(guiValues, 'glitchFx');

		// start all
		init();	
	</script>
</body>
</html>